# -*- coding: utf-8 -*-
"""MochilaAlgoritmo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L2N1WbBH-7BzBW75ng169e7kcexm5Pz6
"""

import random
import numpy;



items = [
    {"name":"map","weight": 9,  "value":150},
    {"name":"compass","weight": 13,  "value":35},
    {"name":"water","weight": 153, "value": 200},
    {"name":"sandwich","weight": 50,  "value":160},
    {"name":"glucose","weight": 15, "value": 60},
    {"name":"tin","weight": 68, "value": 45},
    {"name":"banana","weight": 27,  "value":60},
    {"name":"apple","weight": 39,  "value":40},
    {"name":"cheese","weight": 23,  "value":30},
    {"name":"beer","weight": 52,  "value":10},
    {"name":"suntan cream","weight": 11,  "value":70},
    {"name":"camera","weight": 32,  "value":30},
    {"name":"t-shirt","weight": 24, "value": 15},
    {"name":"trousers","weight": 48,  "value":10},
    {"name":"umbrella","weight": 73,  "value":40},
    {"name":"waterproof trousers","weight": 42,  "value":70},
    {"name":"waterproof overclothes","weight": 43,  "value":75},
    {"name":"note-case","weight": 22, "value": 80},
    {"name":"sunglasses","weight": 7,  "value":20},
    {"name":"towel","weight": 18,  "value":12},
    {"name":"socks","weight": 4,  "value":50},
    {"name":"book","weight": 30,  "value":10},
]

import operator

def etilist(poblation,reverse,poblationSize):
  et=(poblationSize*2/100)
  poblation.sort(key=operator.attrgetter('adaptation'), reverse=reverse)
  for idx, element in enumerate(poblation):
    if(idx<et):
      element.isElite=True
    else:
      element.isElite=False
      
  return poblation[0:poblationSize]

def couplesRoullete(poblation,total):
  sumAdaptation=0
  totalPoblation=len(poblation)
  for x in range(totalPoblation):
    sumAdaptation=sumAdaptation+poblation[x].adaptation

  pi=[]
  qi=[]
  for x in range(totalPoblation):
    poblation[x].pi=(poblation[x].adaptation/sumAdaptation)
    if(x!=0):
      poblation[x].qi=(poblation[x].pi+poblation[x-1].qi)
    else:
      poblation[x].qi=(poblation[0].pi)  

  selection=[]
  for x in range(total):
    s1=numpy.random.random_sample()
    for y in range((totalPoblation)):
      if s1<poblation[y].qi:
        c1=y
    selection.append(poblation[c1])   
  return selection;

def mutation(poblation,prob):
  for element in  poblation:
    s1=numpy.random.random_sample()
    if s1<=prob and not element.isElite:
      element.mutation();
  return poblation

def validWeight(items,elementBag,maxWeight):
  sum=0
  for x in range(len(elementBag)):
    if(elementBag[x]==1):
      sum+=items[x]['weight']

  if(sum>maxWeight):
    return False;

  return True;

def fixSon(element,items,maxWeight):
  sum=0
  for x in range(len(element)):
    if(element[x]==1):
      sum+=items[x]['weight']

  for x in range(len(element)):
    if(element[x]==1):
      sum-=items[x]['weight']
      element[x]=0
      if(sum<=maxWeight):
        break;
  return element;

def reproduction(prob,selection,elementSize,items,maxWeight):
  couples=[]

  for x in range(len(selection)):
    if(numpy.random.random_sample()<=prob):
      couples.append(selection[x])
  
  if len(couples) %2 !=0:
    couples.pop()

  
  cruce=random.randint(1,elementSize-1)
  sons=[]
  for x in range(0,len(couples),2):

    auxCruce=cruce
    son1=couples[x].elementBag[0:auxCruce]+couples[x+1].elementBag[auxCruce:elementSize-1]
    son2=couples[x+1].elementBag[0:auxCruce]+couples[x].elementBag[auxCruce:elementSize-1]
    
    isValid=validWeight(items,son1, maxWeight)
    isValid2=validWeight(items,son2, maxWeight)
    count=0

    while( not isValid or not isValid2 ):
      cruce=random.randint(1,elementSize-1)

      son1=couples[x].elementBag[0:auxCruce]+couples[x+1].elementBag[auxCruce:elementSize-1]
      son2=couples[x+1].elementBag[0:auxCruce]+couples[x].elementBag[auxCruce:elementSize-1]

      isValid=validWeight(items,son1, maxWeight)
      isValid2=validWeight(items,son2, maxWeight)
      if(count==20):
        break;
      count+=1
      
    

    if(not isValid):
      son1=fixSon(son1,items,maxWeight)
      
    if(not isValid2):
      son2=fixSon(son2,items,maxWeight)





    
    sons.append(elementClass(son1,items,maxWeight))
    sons.append(elementClass(son2,items,maxWeight))
    
  return sons

def getInitialPoblation(items,maxWeight,poblationSize):
  totalItems=len(items)
  initialPoblation=[]
  
  for x in range(poblationSize):
    element=[]
    accumulatedWeight=0
    for  y in range(totalItems):
      add=random.randint(0,1)
      if(add==1):
        if((accumulatedWeight+items[y]['weight'])<=maxWeight):
          element.append(1)
         
          accumulatedWeight+=items[y]['weight']
        else:
          element.append(0)

      else:
        element.append(0)
        
    initialPoblation.append(elementClass(element,items,maxWeight))
    
  return initialPoblation;

import math

class elementClass:
  
  def __init__(self, elementBag,items,maxWeight):
    self.elementBag = elementBag
    self.items=items
    self.maxWeight=maxWeight
    self.qi=0
    self.pi=0
    self.isElite=False
    self.adaptation=self.getAdaptation()
    self.weight=self.getWeight()


  def mutation(self):
    elementSize=len(self.elementBag)
    
    con=True
    while(con):
      index= random.randint(0,elementSize-1)

      if self.elementBag[index]==1:
        self.elementBag[index]=0
        con=False
      else:
        if((self.weight+items[index]['weight']<=self.maxWeight)):
          self.elementBag[index]=1
          con=False

    self.adaptation=self.getAdaptation()
    self.weight=self.getWeight()

  def getAdaptation(self):
    sum=0
    for x in range(len(self.elementBag)):
      if(self.elementBag[x]==1):
        sum+=self.items[x]['value']
    return sum;


  def getWeight(self):
    sum=0
    for x in range(len(self.elementBag)):
      if(self.elementBag[x]==1):
        sum+=self.items[x]['weight']
    return sum;

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd    #print("SUMA: "+str(sum))

import seaborn as sns

 
poblationSize=100
maxWeight=400
probRep=0.90
probMut=0.1

newPoblation=getInitialPoblation(items,maxWeight,poblationSize)

generations=100


reverse=True
sons=[]
gainM=[]

for x in range(generations): 
  newPoblation=etilist(newPoblation+sons,reverse,poblationSize)
  gainM.append(newPoblation[0].adaptation)
  
  
  if x == (generations-1):
    break;
    
  if(newPoblation[0].adaptation==newPoblation[poblationSize-1].adaptation):
    break
  selection=couplesRoullete(newPoblation,poblationSize)
  sons=reproduction(probRep,selection,len(items),items,maxWeight)
  sons=mutation(sons,probMut)
  


print(newPoblation[0].adaptation)
print(newPoblation[0].weight)

import numpy as np

plt.plot(range(0,generations), gainM, 'r--')
plt.show()



